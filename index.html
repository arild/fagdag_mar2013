<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8">

    <title>Scala Introduction & Futures and Promises</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet'
          type='text/css'>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/presentation.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write('<link rel="stylesheet" href="css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section class="frontpage">
    <h2>Scala Introduction<br>&<br>Futures and Promises</h2>
    <p>
    <span>Slides: <a href="http://arild.github.io/scala-workshop">http://arild.github.io/scala-workshop</a></span><br>
    <span>Code: <a href="https://github.com/arild/scala-workshop">https://github.com/arild/scala-workshop</a></span>
    </p>
    <p>Arild Nilsen<br>Sjur Millidahl</p>
    <p>October, 2013</p>
</section>

<section class="outline">
    <h2>Outline</h2>
    <ul>
        <li>Introduction</li>
        <li class="inner"><ul>
            <li>Functions</li>
            <li>Collections</li>
            <li>Pattern matching</li>
        </ul></li>
        <li>Futures and Promises</li>
        <li class="inner"><ul>
            <li>Exercises using Futures</li>
            <li>Futures vs. Promises</li>
        </ul></li>
    </ul>
</section>

<section>
    <h2>Functional Programming</h2>
    <ul>
        <li class="fragment">Higher-order functions</li>
        <li class="fragment">Pure functions</li>
        <li class="fragment">Recursion</li>
        <li class="fragment">Avoids state and mutable data</li>
        <li class="fragment">
            <a href="http://pragprog.com/magazines/2013-01/functional-programming-basics">
                <q cite="">
                    Functional programming is programming without assignment statements.</q>
            </a>
            <p style="padding-left: 90px;">Robert C. Martin (Uncle Bob), January 2013</p>
        </li>
    </ul>
</section>

<section>
    <h2>Functions in Scala</h2>
    <div class="fragment">
        <p>Named functions</p>
    <p></p><pre><code>def createList(param1: Int, param2: Int): List[Int] = {
    val myImmutableList = List(param1, param2)
    myImmutableList
}</code></pre>
    </div>
    <div class="fragment">
    <p>Anonymous functions</p>
    <pre><code>(x: Int) => x + 1</code></pre>
    </div>
    <div class="fragment">
    <p>Can be accepted as a parameter</p>
    <pre><code>def myMethod(n: Int, f: Int => Boolean) = f(n)</code></pre>
    </div>
</section>

<section>
    <h2>Collections in Scala</h2>
    <p>
        <img alt="seq" src="seq_tree.png"/>
    </p>
</section>

<section>
    <h2>scala.immutable.List</h2>
    <ul>
        <li class="fragment">Implements isEmpty, head and tail.</li>
        <li class="fragment">O(n) on most operations</li>
        <li class="fragment">O(1) on prepend and head/tail-access</li>
        <li class="fragment">Suitable for recursive solutions based on head:tail-access</li>
        <li class="fragment">Examples:
            <pre><code>scala> 4 :: List(1, 2, 3) // Prepend, O(1)
res0: List[Int] = List(4, 1, 2, 3)</code></pre>
                        <pre><code>scala> List(1, 2, 3) ::: List(4) // Append, O(n), prefer prepend
res1: List[Int] = List(1, 2, 3, 4)</code></pre>
        </li>
    </ul>
</section>


<section>
    <h2>map()</h2>
    <ul>
        <li>map() takes in a function and applies it to all elements</li>
        <li>map() transforms the list according to the function provided</li>

    </ul>

    <pre><code>scala> val numbers = List(1,2,3)
numbers: List[Int] = List(1, 2, 3)

scala> numbers.map((x: Int) => x + 1)
res0: List[Int] = List(2, 3, 4)</code></pre>
</section>

<section>
    <h2>filter()</h2>
    <ul>
        <li>filter() takes inn a function predicate</li>
        <li>filter() returns the subset of this list for which the predicate is true</li>
    </ul>

    <pre><code>scala> val myList = List(1,2,3,4,5,6)
myList: List[Int] = List(1, 2, 3, 4, 5, 6)

scala> myList.filter((x: Int) => x > 3)
res0: List[Int] = List(4, 5, 6)</code></pre>
</section>


<section>
    <h2>scala.immutable.List API examples</h2>
    <pre><code>//Adds an element at the beginning of this list
def ::(x: A): List[A]

//Adds the elements of a given list in front of this list
def :::(prefix: List[A]): List[A]

//Selects the first element of this list
def head: A

//Selects last n elements
def takeRight(n: Int): List[A]

//Selects all elements of this list which satisfy a predicate
def filter(p: (A) â‡’ Boolean): List[A]
</code></pre>
</section>


<section>
    <h2>Pattern matching</h2>
    <p>match on any sort of data with a first-match policy.</p>
    <pre><code>def toYesOrNo(choice: Int): String = choice match {
    case 1 => "yes"
    case 0 => "no"
    case _ => "error"
}</code></pre>
</section>

<section>
    <h2>Pattern matching II</h2>
    <pre><code>def f(x: Any): String = x match {
    case i:Int => "integer: " + i
    case _:Double => "a double"
    case s:String => "I want to say " + s
}</code></pre>
</section>

<section>
    <h2>Do exersices</h2>
    <ul>
        <li class="fragment">git clone https://github.com/arild/scala-workshop.git</li>
        <li class="fragment">Complete predefined tests for MyIntroProblems</li>
        <li class="fragment">Complete predefined tests for MyAdvancedProblems</li>
    </ul>
</section>

<section>
    <h2>Futures and Promises</h2>
    <ul>
        <li class="fragment">SIP-14 - redesign of scala.concurrent</li>
        <li class="fragment">Introduced in Scala 2.10</li>
        <li class="fragment">Placeholder object for a result that does not yet exist</li>
    </ul>
</section>

<section>
    <h2>SIP-14 definition</h2>

    <div class="fragment">
        <blockquote width="900" cite="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">A Future
            is a read-handle to a single value (read-many) that may be available within a specific time-frame
        </blockquote>
        </div>
    <div class="fragment">
        <blockquote width="900" cite="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">A Promise
            is a write-handle to a single value (write-once) that should be made available within a specific
            time-frame
        </blockquote>
        </div>
</section>

<section>
    <h2>Hello Future</h2>

    <div class="fragment">
        <pre><code>println("Test print before future")
val s = "hello"

val f = future {
  Thread.sleep(10)
  s + " future!"
}

println("Test print after future")

// Completely asynchronous
f.onSuccess { case s => println(s) }

// Blocks until the future is ready
Await.ready(f, Duration.Inf)</code></pre>
    </div>
    <div class="fragment">Output: <br/><pre><code>Test print before future
Test print after future
hello future!</code></pre>
    </div>
</section>

<section>
    <h2>Basic Operations on Futures</h2>

    <div class="fragment">
            <pre><code>//Asynchronously processes the value in 
//the future once the value becomes available.
def foreach[U](f: T => U): Unit

//Creates a new future by applying a function to the successful
//result of this future.
def map[S](f: T => S): Future[S]

//Creates a new future by applying a function to the successful 
//result of this future, and returns the result of the function
//as the new future.
def flatMap[S](f: T => Future[S]): Future[S]

//Creates a new future by filtering the value of the current future
//with a predicate.
def filter(p: T => Boolean): Future[T]</code></pre>
    </div>
</section>

<section>
    <h2>Error handling</h2>

    <div class="fragment">
<pre><code>val riskyRes = future { riskyWork() }
val safeRes = future { safeWork() }

val finalRes = riskyRes recoverWith {
  case e: IllegalArgumentException => safeRes
}</code></pre>
    </div>
</section>

<section>
    <h2>Futures are composeable</h2>
    <div class="fragment">
    <pre><code>val keys = future { readFile("keys.txt") }
val values = future { readFile("values.txt") }

val data = keys.zip(values)

val hashMap = data.map((ls: (List[String], List[String])) => {
  ls._1.zip(ls._2).toMap
})

hashMap.recover {
  case e: FileNotFoundException => {
    Map[String, String]()
  }
}.onSuccess {
  case map => {
    println(map)
  }
}

Await.result(hashMap, Duration.Inf)</code></pre>
        </div>
</section>

<section>
    <h2>Do exersices</h2>
    <ul>
        <li class="fragment">git clone https://github.com/arild/scala-workshop.git</li>
        <li class="fragment">Complete predefined tests for MyFutures</li>
    </ul>
</section>

<section>
    <h2>"Futures" vs. "Promises"</h2>
    <ul>
        <li class="fragment">"Future", "promise", "delay" and "deferred" used interchangeably</li>
        <li class="fragment">Complementary primitives</li>
        <li class="fragment">"Promise" exclusively used in the JavaScript world</li>
    </ul>
</section>

<section>
    <h2>Producer Consumer Example</h2>

    <div class="fragment">
<pre><code>val p = promise[T]
val f = p.future

val producer = future {
  val result = produceSomething()
  p success result
  continueDoingSomethingUnrelated()
}

val consumer = future {
  startDoingSomething()
  f onSuccess {
    case res => doSomething(res)
  }
}</code></pre>
    </div>
</section>

<section>
    <h2>Resources</h2>
    <ul>
        <li><a href="http://docs.scala-lang.org/overviews/core/futures.html">Scala Documentation - Futures and Promises</a></li>
        <li><a href="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">Scala Days 2012 - The Future I was Promised</a></li>
        <li><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You're Missing the Point of Promises</a></li>
    </ul>
</section>

<section>
    <h2>Questions?</h2>
    <span>Slides: <a href="http://arild.github.io/scala-workshop">http://arild.github.io/scala-workshop</a></span><br>
    <span>Code: <a href="https://github.com/arild/scala-workshop">https://github.com/arild/scala-workshop</a></span>
</section>

</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
            { src: 'lib/js/highlight.js', async: true, callback: function () {
                window.hljs.initHighlightingOnLoad();
            } },
            { src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            } },
            { src: 'lib/js/showdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'lib/js/data-markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'plugin/zoom-js/zoom.js', condition: function () {
                return !!document.body.classList;
            } },
            { src: '/socket.io/socket.io.js', async: true, condition: function () {
                return window.location.host === 'localhost:1947';
            } },
            { src: 'plugin/speakernotes/client.js', async: true, condition: function () {
                return window.location.host === 'localhost:1947';
            } }
        ]
    });

</script>

</body>
</html>
