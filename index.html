<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8">

    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet'
          type='text/css'>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/presentation.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write('<link rel="stylesheet" href="css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
    <h2>Scala Introduction<br>&<br>Futures and Promises</h2>
    <p>
    <span>Slides: <a href="http://arild.github.com/fagdag_mar2013">http://arild.github.com/fagdag_mar2013</a></span>
    <span>Code: <a href="https://github.com/arild/fagdag_mar2013">https://github.com/arild/fagdag_mar2013</a></span>
    </p>
    <p>Arild Nilsen<br>Sjur Millidahl</p>
    <p>Mars, 2013</p>
</section>

<section>
    <h2>Outline</h2>
    <ul>
        <li>Introduction</li>
        <li><ul>
            <li>Functions</li>
            <li>Collections</li>
            <li>Pattern matching</li>
        </ul></li>
        <li>Futures and Promises</li>
        <li><ul>
            <li>Exercises using Futures</li>
            <li>Futures vs. Promises</li>
        </ul></li>
    </ul>
</section>

<section>
    <h2>Funksjoner I</h2>
    <div>
    <p></p><pre><code>def myListMaker(para1: Int, para2: Int): List[Int] = {
    val myImmutableList = List(para1, para2)
    println(myImmutableList)
    myImmutableList
}</code></pre>
    </div>

    <h2>Anonym funksjon i Scala</h2>
    <pre><code>(x: Int) => x + 1</code></pre>
        </section>

        <section>
                <h2>Funksjoner II</h2>
                <p>Kan sendes inn til andre funksjoner</p>
        <pre><code>if(iWantTo)
    myObject.myMethod(myFunction)</code></pre>
</section>

<section>
    <h2>Funksjoner III</h2>
    <p>Kan tas inn som en parameter</p>
    <pre><code>def myMethod(n: Int, f: Int => Boolean) = f(n)</code></pre>
</section>

<section>
    <h2>Collections I</h2>
    <p>
        <img alt="seq" src="seq_tree.png"/>
    </p>
</section>

<section>
    <h2>Collections II - scala.immutable.List</h2>
    <ul>
        <li>Alle elementer i en liste er enten av typen scala.Nil (List()) eller scala.:: (ikke-tom) <br />
            som implementerer isEmpty, head og tail.</li>
        <li>O(n) på de fleste operasjoner</li>
        <li>0(1) på prepend og head/tail-access</li>
        <li>Egnet for rekursive løsninger basert på head:tail-aksess</li>
        <li>Lages slik
            <pre><code>val myList = List(1,2,3)</code></pre>
        </li>
    </ul>
</section>

<section>
    <h2>Collections III - scala.immutable.List</h2>
    <pre><code>//Adds an element at the beginning of this list.
def ::(x: A): List[A]
//Adds the elements of a given list in front of this list.
def :::(prefix: List[A]): List[A]
//Selects all elements of this list which satisfy a predicate.
def filter(p: (A) ⇒ Boolean): List[A]
Splits this list into a prefix/suffix pair according to a predicate.
def span(p: (A) ⇒ Boolean): (List[A], List[A])</code></pre>
</section>

<section>
    <h2>map() and filter()</h2>
    <ul>
        <li class="fragment">map() takes in a function and applies it to all elements</li>
        <li class="fragment">map() transforms the list according to the function provided</li>
        <li class="fragment">filter() takes inn a function predicate</li>
        <li class="fragment">filter() returns the subset of this list for which the predicate is true</li>
    </ul>
</section>

<section>
    <h2>Eksempel</h2>
    <pre><code>scala> val numbers = List(1,2,3)
numbers: List[Int] = List(1, 2, 3)

scala> numbers.map((x: Int) => x + 1)
res0: List[Int] = List(2, 3, 4)</code></pre>
</section>

<section>
    <h2>Shared Memory</h2>
    <ul>
        <li class="fragment">Communicate by altering shared memory</li>
        <li class="fragment">Unpredictable results if unguarded (race conditions)</li>
        <li class="fragment">Difficult to get correct and to reason about</li>
        <li class="fragment">Might be difficult to scale (lock contention)</li>
        <li class="fragment">Deadlocks</li>
    </ul>
</section>


<section>
    <h2>Do exersices</h2>
    <ul>
        <li class="fragment">git clone https://github.com/arild/actors_presentation.git</li>
        <li class="fragment">git checkout actors</li>
        <li class="fragment">Complete predefined tests for Actor and implementation of Actor</li>
    </ul>
</section>

<section>
    <h2>Futures and Promises</h2>
    <ul>
        <li class="fragment">SIP-14 - redesign of scala.concurrent</li>
        <li class="fragment">Introduced in Scala 2.10</li>
        <li class="fragment">Placeholder object for a result that does not yet exist</li>
    </ul>
</section>

<section>
    <h2>SIP-14 definition</h2>

    <div class="fragment">
        <blockquote width="900" cite="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">A Future
            is a read-handle to a single value (read-many) that may be available within a specific time-frame
        </blockquote>
        </div>
    <div class="fragment">
        <blockquote width="900" cite="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">A Promise
            is a write-handle to a single value (write-once) that should be made available within a specific
            time-frame
        </blockquote>
        </div>
</section>

<section>
    <h2>Basic Operations on Futures</h2>

    <div class="fragment">
            <pre><code>def foreach[U](f: T => U): Unit

def map[S](f: T => S): Future[S]

def flatMap[S](f: T => Future[S]): Future[S]

def filter(p: T => Boolean): Future[T]</code>
            </pre>
    </div>
</section>

<section>
    <h2>Future code example</h2>

    <div class="fragment">
        <pre><code>
println("Test print before future")
val s = "hello"

val f = future {
  Thread.sleep(10)
  s + " future!"
}

println("Test print after future")
f onSuccess { case s => println(s) } //Completely asynchronous
Await.ready(f, Duration.Inf) //Blocks until the future is ready
</code>
        </pre>
    </div>
    <div class="fragment">Output: <br/><pre><code>Test print before future
Test print after future
hello world!
    </code></pre>
        </div>
</section>

<section>
    <h2>Futures are composeable (1)</h2>
    <pre><code>
val rateQuote = future {
  connection.getCurrentValue(USD)
}

rateQuote onSuccess { case quote =>
  val purchase = future {
    if (isProfitable(quote)) connection.buy(amount, quote)
    else throw new Exception("not profitable")
  }

  purchase onSuccess {
    case _ => println("Purchased " + amount + " USD")
  }
}
</code></pre>
</section>


<section>
    <h2>Futures are composeable (2)</h2>
    <pre><code>val rateQuote = future {
  connection.getCurrentValue(USD)
}

val purchase = rateQuote map { quote =>
  if (isProfitable(quote)) connection.buy(amount, quote)
  else throw new Exception("not profitable")
}

purchase onSuccess {
  case _ => println("Purchased " + amount + " USD")
}
</code></pre>
</section>


<section>
    <h2>Futures are composeable (2)</h2>
    <pre><code>
  val keys = future { readFile("keys.txt") }
  val values = future { readFile("values.txt") }

  val data = keys.zip(values);

  val hashMap = data.map((ls: (List[String], List[String])) => {
    ls._1.zip(ls._2).toMap
  })

  hashMap.recover {
    case e: FileNotFoundException => {
      Map[String, String]()
    }
  }.onSuccess {
    case map => {
      println(map)
    }
  }

  Await.result(data, Duration.Inf)</code></pre>
</section>


<!--<section>-->
    <!--<h2>Promise code example</h2>-->

    <!--<div class="fragment">-->
        <!--<p class="fragment"><pre><code>-->
<!--val f = future {-->
  <!--Thread.sleep(10)-->
  <!--println("Computing sum...")-->
  <!--new SumSequence(0, 2).perform-->
<!--}-->
<!--val p = promise[Int]()-->
<!--p completeWith f-->
<!--val result = Await.result(p.future, Duration.Inf)-->
<!--println("Sum = " + result)-->
<!--</pre>-->
        <!--</code></p>-->
    <!--</div>-->
    <!--<div class="fragment"><p>Output: <br/><pre><code>Computing sum...-->
        <!--Sum = 3</code></pre>-->
        <!--</p></div>-->
<!--</section>-->

<section>
    <h2>Error handling</h2>

    <div class="fragment">
        <pre><code>val p = promise[Int]()
val riskyRes = future { riskyOperation.perform }
val safeRes = future { safeOperation.perform }
p completeWith {
  riskyRes recoverWith { 
    case e: IllegalArgumentException => safeRes
  }
}</code></pre>
    </div>
</section>

<section>
    <h2>Do exersices</h2>
    <ul>
        <li class="fragment">git checkout futures</li>
        <li class="fragment">Keep your promises - make the tests green!</li>
        <li class="fragment">If stuck or finished: git checkout master</li>
    </ul>
</section>

<section>
    <h2>Resources</h2>
    <ul>
        <li><a href="http://docs.scala-lang.org/overviews/core/futures.html">Scala Documentation - Futures and Promises</a></li>
        <li><a href="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">Scala Days 2012 - The Future I was Promised</a></li>
        <li><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You're Missing the Point of Promises</a></li>
    </ul>
</section>

<section>
    <h2>Questions?</h2>
    <span>Slides: </span><a href="http://arild.github.com/fagdag_mar2013">http://arild.github.com/fagdag_mar2013</a>
    <span>Code: </span><a href="https://github.com/arild/fagdag_mar2013">https://github.com/arild/fagdag_mar2013</a>
</section>

</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
            { src: 'lib/js/highlight.js', async: true, callback: function () {
                window.hljs.initHighlightingOnLoad();
            } },
            { src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            } },
            { src: 'lib/js/showdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'lib/js/data-markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: 'plugin/zoom-js/zoom.js', condition: function () {
                return !!document.body.classList;
            } },
            { src: '/socket.io/socket.io.js', async: true, condition: function () {
                return window.location.host === 'localhost:1947';
            } },
            { src: 'plugin/speakernotes/client.js', async: true, condition: function () {
                return window.location.host === 'localhost:1947';
            } }
        ]
    });

</script>

</body>
</html>
