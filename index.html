<!doctype html>  
<html lang="en">
	
	<head>
		<meta charset="utf-8">
		
		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		
		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
		
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	
	<body>
		
		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
    <section>
	<h1>Concurrency abstractions in Scala</h1>
	<p>https://github.com/arild/actors_presentation</p>
        <p>Arild Nilsen<br>Sjur Millidahl</p>
	<br>
	<p>October, 2012</p>
    </section>

    <section>
        <h2>Motivatation</h2>
        <div class="fragment"><p><img src="tile-gx_diagram.gif"</p></div>
        <div class="fragment"><p><img src="tilera.png"</p></div>
	<div class="fragment"><p>Higher level of abstraction for concurrency</p></div>
    </section>

    <section>
        <h2>Shared Memory</h2>
        <ul>
        <li class="fragment">Communicate by altering shared memory</li>
        <li class="fragment">Unpredictable results if unguarded (race conditions)</li>
        <li class="fragment">Difficult to get correct and to reason about</li>
        <li class="fragment">Might be difficult to scale (lock contention)</li>
        <li class="fragment">Deadlocks</li>
        </ul>
    </section>

    <section>
        <h2>Actors</h2>
        <ul>
        <li class="fragment">Lightweight processes</li>
        <li class="fragment">No shared state</li>
        <li class="fragment">Inherently concurrent</li>
        <li class="fragment">Communicate using asynchronous messages</li>
        <li class="fragment">Messages buffered in an inbox</li>
        <li class="fragment">Tends to be easier to reason about</li>
        </ul>
    </section>

    <section>
        <h2>Akkar</h2>
	<ul>
	    <li class="fragment">"Todarodes sagittatus" has 10 tentacles and likes to swim with other Akkars</li>
	    <li class="fragment">Two-thirds of an octopus's neurons are found in the nerve cords of its arms, which have limited functional autonomy</li>
	    <li class="fragment">Octopus arms show a variety of complex reflex actions that persist even when they have no input from the brain</li>
	    <li class="fragment">.. in other words Akkar-tentacle=Actor</li>
	</ul>
        <div class="fragment"><p><img src="akkar.gif"/></p></div>
    </section>

    <section>
        <h2>Example Actor</h2>
        <div class="fragment"><p><pre><code>import scala.actors.Actor

class MyActor extends Actor {
  def act(){
    receive {
      case s: String => sender ! response
    }
  }
}</code></pre></p></div><br />
<div class="fragment"><p><code><pre>
val actor = new MyActor
actor.start
actor ! "hello"</pre></code></p></div>
    </section>

    <section>
        <h2>Messages</h2>
        <ul>
            <li class="fragment">! send async</li>
            <li class="fragment">!? sends synchronously (wait for result)</li>
            <li class="fragment">!! send and receive future</li>
        </ul>
    </section>

    <section>
        <h2>specs2</h2>
        <ul>
            <li class="fragment">used in code examples</li>
            <li class="fragment">"prose-driven" test-framework</li>
        </ul>
        <div class="fragment"><p><pre><code>
"ComputeActor" should {
  "compute length of string" in {
    val result = ...
    result must beEqualTo(5)
  }
} 
</code></pre></p></div>
    </section>

    <section>
        <h2>Do exersices</h2>
        <ul>
        <li class="fragment">git clone https://github.com/arild/actors_presentation.git</li>
        <li class="fragment">git checkout actors</li>
        <li class="fragment">Complete predefined tests for Actor and implementation of Actor</li>
        </ul>
    </section>

    <section>
        <h2>Futures and Promises</h2>
        <ul>
        <li class="fragment">SIP-14 - redesign of scala.concurrent</li>
        <li class="fragment">Placeholder object for a result that does not yet exist</li>
        </ul>
    </section>

    <section>
        <h2>SIP-14 definition</h2>
        <div class="fragment"><p><blockquote width="900" cite="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">A Future is a read-handle to a single value (read-many) that may be available within a specific time-frame</blockquote></p></div>
        <div class="fragment"><p><blockquote width="900" cite="http://skillsmatter.com/podcast/scala/the-future-i-was-promised">A Promise is a write-handle to a single value (write-once) that should be made available within a specific time-frame</blockquote></p></div>
        <div class="fragment"><p>http://skillsmatter.com/podcast/scala/the-future-i-was-promised</p></div>
    </section>

    <section>
        <h2>Basic Operations on Futures</h2>
	<div class="fragment">
        <p>
        <code><pre>def foreach[U](f: T => U): Unit

def map[S](f: T => S): Future[S]

def flatMap[S](f: T => Future[S]): Future[S]

def filter(p: T => Boolean): Future[T]</pre></code>
        </p>
	</div>
    </section>

    <section>
        <h2>Future code example</h2>
        <div class="fragment"><p><code><pre>
println("Test print before future")
val s = "hello"
val f = future {
  Thread.sleep(10)
  s + " future!"
}
println("Test print after future")
f onSuccess { case s => println(s) } //Completely asynchronous
Await.ready(f, Duration.Inf) //Blocks until the future is ready
</pre></code></p></div>
       <div class="fragment"><p>Output: <br /><pre><code>Test print before future
Test print after future
hello world!
</code></pre></p></div>
    </section>

    <section>
        <h2>Promise code example</h2>
        <div class="fragment"><p  class="fragment"><code><pre>
val f = future {
  Thread.sleep(10)
  println("Computing sum...")
  new SumSequence(0, 2).perform
}
val p = promise[Int]()
p completeWith f
val result = Await.result(p.future, Duration.Inf)
println("Sum = " + result)
</pre></code></p></div>
       <div class="fragment"><p>Output: <br /><pre><code>Computing sum...
Sum = 3</code></pre></p></div>
    </section>

    <section>
        <h2>recoverWith code example</h2>
        <div class="fragment"><p  class="fragment"><code><pre>val p = promise[Int]()
val riskyRes = future { riskyOperation.perform }
val safeRes = future { safeOperation.perform }
p completeWith {
  riskyRes recoverWith { 
    case e: IllegalArgumentException => safeRes
  }
}</code></pre></p></div>
    </section>

    <section>
        <h2>Do exersices</h2>
        <ul>
        <li class="fragment">git checkout futures</li>
        <li class="fragment">Keep your promises - make the tests green!</li>
        <li class="fragment">If stuck or finished: git checkout master</li>
        </ul>
    </section>
</div>			
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			
			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				
				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/zoom-js/zoom.js', condition: function() { return !!document.body.classList; } },
					{ src: '/socket.io/socket.io.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
					{ src: 'plugin/speakernotes/client.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } }
				]
			});
			
		</script>

	</body>
</html>
